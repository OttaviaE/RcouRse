---
title: "An int`R`oduction to `R`"
date: 'Erasmus+ QHelp seminar, Padova, July 2022'
author: "Ottavia M. Epifania"
institute: "Univerisity of Padova (IT)"
output: 
  beamer_presentation: 
    theme: Metropolis
    colortheme: beaver
    fonttheme: serif
    highlight: haddock
header-includes:
    - \usepackage{graphicx} 
    - \usepackage{setspace}
    - \usepackage{tabularx}
    - \usepackage[english]{babel}
    - \usepackage{tikzsymbols}
    - \usepackage{subcaption}
    - \usepackage{tikz}
    - \usepackage{spot}
    - \usepackage{tabularx}
    - \usepackage[absolute,overlay]{textpos}
    - \usepackage{booktabs}
    - \newcommand\Factor{1.2}
    - \setbeamerfont{subtitle}{size=\large, series=\bfseries}
    - \definecolor{template}{RGB}{181, 18, 27}
    - \setbeamercolor{frametitle}{bg=white}
    - \setbeamertemplate{frametitle}[default][center]
    - \AtBeginSection{\frame{\sectionpage}}
    - \setbeamercolor{section name}{fg=white}
    - \setbeamercolor{title}{fg=template}
    - \setbeamercolor{section title}{fg=template}
    - \setbeamercolor{frame subtitle}{fg=template}
    - \setbeamersize{text margin left=5mm,text margin right=5mm} 
#    - \setbeamertemplate{navigation symbols}[horizontal] 
    - \AtBeginSection[]
          {
             \begin{frame}
             \frametitle{Table of Contents}
             \tableofcontents[currentsection]
              \end{frame}
            }  
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      eval = TRUE, 
                      message = FALSE, 
                      comment="", 
                      tidy=FALSE, 
                      warning = FALSE, 
                      fig.align = "center", 
                      out.width = "70%")
library(ggplot2)
library(gridExtra)
hook_output <- knitr::knit_hooks$get("output")
knitr::knit_hooks$set(output = function(x, options) {
if (!is.null(n <- options$out.lines)) {
x <- xfun::split_lines(x)
if (length(x) > n) {
# truncate the output
x <- c(head(x, n), "....\n")
} 
x <- paste(x, collapse = "\n")
} 
hook_output(x, options)
})
set.seed(9999)
library(knitr)
```



## Table of contents

\tableofcontents

## Course material 

```{r out.width="60%", fig.align='center', echo=FALSE}
knitr::include_graphics("img/qr-code.png")
```

NB: This material is based on the lessons by Dr. Florian Wickelmaier


# Who aRe you?

##

- `R` is an open source software for statistical computing, graphics, and so much more

- `RStudio` is the perfect IDE for `R`  $\rightarrow$ allows for a better, easier use of `R` 

- `R` runs on Windows, MacOs, Unix

## Calculato`R`

```{r eval = FALSE} 
3 + 2   # plus
3 - 2   # minus
3 * 2   # times
3 / 2   # divide
sqrt(4) # square root
log(3)  # natural logarithm
exp(3)  # exponential
```

Use brackets as you would do in a normal equation:

```{r eval = FALSE}
(3 * 2)/ sqrt(25 + 4) # Lokk at me!
```

`R` ignores everything after # (it's a comment)

## Assign 

The results of the operations can be "stored" into objects with specific names defined by the users. 

To assign a value to an object, there are two operators: 

1. `x = exp(2^2)`

2. `X <- log(2^2)`

The elements on the right are assigned to the object on the left 

\textcolor{red}{Careful!} `R` is case sensitive: `x` and `X` are two different objects!!!

## Variable names

```{r echo = FALSE, out.width="45%"}
knitr::include_graphics("img/meme.jpg")
```

Valid variable names are letters, numbers, dots, underscores (e. g.,
`variable_name`)

Variable names cannot start with numbers

Again, `R` is case sensitive




# Get help

## 

 `R` is open source and it used world wide $\rightarrow$ there's a huge community ready to help you

Just copy \& paste any error message or warning in Google or ask Google "how to **[something]** in r"

 Ask `R` to help you! Type `?` in your console followed by the name of the function:

    ?mean()

Will show you the help page of the `mean()` function

# Be tidy

## Organize your files

`R` projects are the best way to organize your files (and your workflow)

They allow you to have all your files in a folder organized in sub folders 

You don't have to worry about the wording directories because it's all there!

By creating a new project, you can also initialize a Shiny app 

## Create a new `R` project

File $\rightarrow$ New project and choose what is best for you (unless you have already initialized a directory for your project, select a new directory): 

- `R` project "basic"

- `R` package

- `Shiny` project

and so much more


## Take out the trash

The `R` environment should be always tidy

If it feels like you're losing it, just clean it up: 

```{r eval = FALSE}
ls() # list objects in the envrinoment
rm(A) # remove object A from the environment
rm(list=ls()) # remove everything from the environment
```


## Save the environment

It might be useful to save all the computations you have done: 

```{r eval = FALSE}
save.image("my-computations.RData")
```
 
Then you can upload the environment back:

```{r eval=FALSE}
load("my-Computations.RData")
```

## When to save the environment

The computations are slow and you need them to be always and easily accessible 

The best practice is to save the script and document it in an `RMarkdown` file $\rightarrow$ Reproducibilty!



# Working directories

## 

If you choose not to use the `R` projects (\small what a bad, bad, bad idea \normalsize), you need to know your directories: 

```{r eval=FALSE}
getwd() # the working directory in which you are right now

dir() # list of what's inside the current working directory 
```

Change your working directory: 

```{r eval = FALSE}
setwd("C:/Users/huawei/OneDrive/Documenti/GitHub/RcouRse")
```


# Structures in `R`

## Functions and arguments (pt. I)

Almost everything in `R` is done with functions, consisting of: 

- a name: `mean`

- a pair of brackets: `()`

- some arguments: `na.rm = TRUE`

```{r}
mean(1:5, trim = 0, na.rm = TRUE)
```
Arguments may be set to default values; what they are is
documented in `?mean` 

## Functions and arguments (pt. II)

Arguments can be passed

- without name (in the defined order) 

- with name (in arbitrary order) $\rightarrow$ *keyword matching*

    mean(x, trim = 0.3, na.rm = TRUE)

No arguments? No problems, just brackets: 
    
    ls(), dir(), getwd()
    
Want to see the code of a function? Just type its name in the console without brackets: 

    chisq.test

## Vectors

Vectors are created by **c**ombining together different objects

Vectors are created by using the `c()` function. 

All elements inside the `c()` function **must** be separated by a comma

Different types of objects $\rightarrow$ types of vectors: 

- `int`: numeric integers 
- `num`: numbers
- `logi`: logical
- `chr`: characters
- `factor`: factor with different levels



## `int` and `num`

`int`: refers to integer: `r -3:3`

```{r}
months = c(5, 6, 8, 10, 12, 16)
```

```{r echo = FALSE}
months
```


`num`: refers to all numbers from $-\infty$ to $\infty$: `r rnorm(6)`

```{r}
weight = seq(3, 11, by = 1.5) 
```

```{r echo = FALSE}
weight
```

## `logi`

Logical values can be `TRUE` (`T`) or `FALSE` (`F`)

```{r}
v_logi = c(TRUE, TRUE, FALSE, FALSE, TRUE)
```

```{r echo = FALSE}
v_logi
```

logical vectors are often obtained from a comparison:

```{r}
months > 12
```
## `chr` and `factor`

`chr`: characters: `r c(letters[1:3], LETTERS[4:6])`

```{r}
v_chr = c(letters[1:3], LETTERS[4:6])
```

```{r echo = FALSE}
v_chr 
```


`factor`: use numbers or characters to identify the variable levels

```{r}
ses = factor(c(rep(c("low", "medium", "high"), each = 2)))
```

```{r echo = FALSE}
ses
```

Change order of the levels: 

```{r}
ses1 = factor(ses, levels = c("medium", "high", "low")) 
```
```{r echo = FALSE}
ses1
```



## Create vectors

\small

Concatenate elements with `c()`: `vec = c(1, 2, 3, 4, 5)`

Sequences: 

```{r}
-5:5 # vector of 11 numbers from -5 to 5

seq(-2.5, 2.5, by = 0.5) # sequence in steps of 0.5 from -2.5 to 2.5
```

Repeating elements: 

```{r}
rep(1:3, 4)
```

## Create vectors II


```{r}
rep(c("condA", "condB"), each = 3)
```

```{r}
rep(c("on", "off"), c(3, 2))
```
```{r}
paste0("item", 1:4)
```



## Don't mix them up \small unless you truly want to

`int` + `num` $\rightarrow$ `num` 

`int`/`num` + `logi` $\rightarrow$ `int`/`num` 

`int`/`num` + `factor` $\rightarrow$ `int`/`num` 

`int`/`num` + `chr` $\rightarrow$ `chr`

`chr` + `logi` $\rightarrow$ `chr`


## Vectors and operations

Vectors can be summed/subtracted/divided and multiplied with one another


```{r}
a = c(1:8)
a
b = c(4:1)
b 

a - b
```
If the vectors do not have the same length, you get a warning

## Vectors and operations PT. II

The function is applied to each value of the vector:

```{r}
sqrt(a)
```
The same operation can be applied to each element of the vector: 

```{r}
(a - mean(a))^2 # squared deviation
```

## Matrices and arrays

Create a $3 \times 4$ matrix: 

```{r}
A = matrix(1:12, nrow=3, ncol = 4, byrow = TRUE)
```


Label and transpose: 

```{r, tidy=TRUE}
rownames(A) = c(paste("a", 1:3)) # colnames() 
t(A)                             # transpose matrix
```


## Matrices and arrays

Matrix can be created by concatenating columns or rows: 

```{r eval=FALSE}
cbind(a1 = 1:4, a2 = 5:8, a3 = 9:12) # column bind
rbind(a1 = 1:4, a2 = 5.8, a3 = 9:12) # row bind
```

##  Matrices and arrays

\small 

    array(data, c(nrow, ncol, ntab))


```{r}
my_array = array(1:30, c(2, 5, 3)) # 2 x 5 x 3 array
```

\footnotesize

```{r echo=FALSE, out.lines=14}
my_array
```


## Work with vectors, matrices, arrays

Index elements in vectors: `vector_name[position]`

```{r eval=FALSE}
weight[2]        # second element in vector weight
weight[6] = 15.2 # replace sixth element of weight
weight[seq(1, 6, by = 2)] # elements 1, 3, 5 
weight[2:6]      # elements 2 to 6
weight[-2]      # without element 2
```
Logic applies as well: 

```{r  eval=FALSE}
weight[weight > 7] # values greater than 7
weight[weight >= 4.5 & weight < 8] # values between 4.5 
                                   # and 8
```



## Work with vectors, matrices, arrays II

Index elements in matrices: `matrix_name[row, column]`

```{r eval = FALSE}
A[2, 3] # cell in row 2 column 3

A[2, ] # second row

A[, 3] # third column
```
## Work with vectors, matrices, arrays III

Index elements in arrays `array_name[row, col, tab]`

```{r eval = FALSE}
my_array[2, 1, 3] # cell in 2nd row 1st col of 3rd tab
```

```{r eval = FALSE}
my_array[, , 3] # 3rd tab

my_array[1, ,2] # 1st row in tab 2
```



## Lists 

Can store different objects (e.g., vectors, data frames, other lists): 

```{r}
my_list = list(w = weight, m = months, s = ses1, a = A)
```

The components of the list can be indexed with `$` or `[[]]` and the name (or position) of the component: 

Extract `months`:

```{r}
my_list[["m"]] # my_list$m
```

Extract `weight`: 

```{r}
my_list[[1]] # my_list$weight or my_list[["w"]]
```


# The king of data structure: data frames

##

Data frames are lists that consist of vectors and factors of equal
length. The rows in a data frame refer to one unit: 


```{r}
id = paste0("sbj", 1:6)
babies = data.frame(id, months, weight)
```

```{r echo=TRUE}
babies
```


## Working with data frames

Index elements in a data frame: 

```{r eval = FALSE}
babies$months # column months of babies

babies$months[2] # second element of column months

babies[, "id"] # column id

babies[2, ] # second row of babies (obs on baby 2)
```

Logic applies: 

```{r eval = FALSE}
babies[babies$weight > 7, ] # all obs above 7 kg
babies[babies$id %in% c("sbj1", "sbj6"), ] # obs of sbj1 
                                           # and sbj7
```



## Working with data frames II

```{r}
dim(babies) # show the dimensions of the data frame

names(babies) # variable names (= colnames(babies))

```


```{r eval=FALSE}
View(babies) # open data viewer

plot(babies) # pariwise plot
```

\vfill

\footnotesize You can use these commands also on other `R` objects

## Working with data frames III


```{r}
str(babies) # show details on babies
```

```{r}
summary(babies) # descriptive statistics 
```



## Sorting

\small

`order()`: 

```{r}
babies[order(babies$weight), ] # sort by increasing weight
```
```{r eval = FALSE}
babies[order(babies$weight,    # sort by decreasing weight
             decreasing = T), ] 
```

Multiple arguments in `order`: 

```{r eval = FALSE}
babies[order(babies$weight, babies$months, decreasing = TRUE), ]         
```

## Aggregating

Aggregate a response variable according to grouping variable(s) (e.g., averaging per experimental conditions): 

```{r eval = FALSE}
# Single response variable, single grouping variable
aggregate(y ~ x, data = data, FUN, ...)

# Multiple response variables, multiple grouping variables
aggregate(cbind(y1, y2) ~ x1 + x2, data = data, FUN, ...)
```

## Aggregating: Example

\small

```{r out.lines=4}
ToothGrowth # Vitamin C and tooth growth (Guinea Pigs)
```

```{r}
aggregate(len ~ supp + dose, data = ToothGrowth, mean)
```
## Reshaping: Long to wide

Data can be organized in wide format (i.e., one line for each statistical unit) or in long format (i.e., one line for each observation). 

```{r out.lines = 7}
Indometh # Long format
```


## Long to wide

\small

```{r tidy=TRUE, tidy.opts=list(width.cutoff=60), out.lines=3}
# From long to wide
df.w <- reshape(Indometh, v.names="conc", 
                timevar="time",
                idvar="Subject", direction="wide")
```

```{r out.width="70%", out.lines=8, echo = FALSE}
df.w
```


## Reshaping: Wide to long

\small

```{r tidy=TRUE, tidy.opts=list(width.cutoff=60)}
# From wide to long
df.l <- reshape(df.w, varying=list(2:12), 
                v.names="conc", 
                idvar="Subject", direction="long",
times=c(.25, .5, .75, 1, 1.25, 2, 3, 4, 5, 6, 8))
```

```{r echo=FALSE, out.lines=4}
df.l
```

```{r out.lines=4}
df.l[order(df.l$Subject), ] # reorder by subject

```

# Data input and output

## Reading tabular txt files: 

`ASCII` text files in tabular or spread sheet form (one line per
observation, one column per variable) are read using
`read.table()`

```{r eval = FALSE}
data = read.table("C:/RcouRse/file.txt", header = TRUE)
```

`data` is a data frame where the original numerical variables are converted in numeric vectors and character variables are converted in factors (not always). 

Arguments: 

- `header`: variable names in the first line? `TRUE/FALSE`
- `sep`: which separator between the columns (e.g., comma, `\t`)
- `dec`: `1.2` or `1,2`?


## Reading other files

```{r eval = F, tidy=FALSE}
data = read.csv("C:/RcouRse/file.csv", 
                header = TRUE, sep = ";", 
                dec = ",")
```

From SPSS (file `.sav`):

```{r eval=FALSE}
install.packages("foreign")
library(foreign)
data = read.spss("data.sav", to.data.frame = TRUE)
```


## Combine data frames

If they have the same number of columns/rows

```{r eval = FALSE}
all_data = rbind(data, data1, data2) # same columns
all_data = cbind(data, data1, data2) # same rows
```

If they have different rows/columns but they share at least one characteristic (e.g., `ID`): 

```{r eval=FALSE}
all_data = merge(data1, data2, 
                 by = "ID")
```


If there are different IDs in the two datasets $\rightarrow$ added in new rows

`all_data` contains all columns in `data1` and `data2`. The columns of the IDs in `data1` but not in `data2` (and vice versa) will be filled with `NA`s accordingly

## Export data

Writing text (or csv) file: 

```{r eval=FALSE}
write.table(data, # what you want to write 
            file = "mydata.txt", # its name + extension
            header = TRUE, # first row with col names?
            sep = "\t",  # column separator 
            ....) # other arguments
```

`R` environment (again): 

```{r eval=FALSE}
save(dat, file = "exp1_data.rda") # save something specific 
save(file = "the_earth.rda")      # save the environment
load("the_earth.rda")             # load it back
```

# Programming 

## 

Be ready to make mistakes (a lot of mistakes)

Coding is ~~hard~~ art

Think like a computer would think $\rightarrow$ not one gigantic problem but a series of small problems leading to a big solution

Remember: You're not alone `stackoverflow` (or Google in general) is your best friend


## `ifelse()`

Conditional execution: 

Easy: `ifelse(test, if true, if false)` 

```{r eval=TRUE}
ifelse(weight > 7, "big boy", "small boy")
```
\begin{exampleblock}{Pros}

- Super easy to use
- Can embed multiple \texttt{ifelse()} cycles
\end{exampleblock}


\begin{alertblock}{Cons}

- It works fine until you have simple tests
\end{alertblock}

## `if () {} else {}`

If you have only one condition: 

```{r eval = FALSE}
if (test_1) {
  command_1
} else {
  command_2
}
```

## `if () {} else {}`

Multiple conditions: 

```{r eval = FALSE}
if (test_1) {
  command_1
} else if (test_2) {
  command_2
} else {
  command_3
}
```

`test_1` (and `test_2`, if you have it) **must** evaluate in either `TRUE` or `FALSE`

```{r eval = FALSE}
if(!is.na(x)) y <- x^2 else stop("x is missing")
```


## Loops 

`for()` and `while()`

Repeat a command over and over again: 

```{r eval = FALSE}
# Don't do this at home
x <- rnorm(10)      
y <- numeric(10)   # create an empty container 
for(i in seq_along(x)) {
y[i] <- x[i] - mean(x)
}
```

The best solution would have been: 

```{r eval=FALSE}
y = x - mean(x)
```

## Avoiding loops

Don't loop, `apply()`! 

`apply()`


```{r eval = F, tidy=FALSE}
X <- matrix(rnorm(20),
            nrow = 5, ncol = 4)
apply(X, 2, max) # maximum for each column
```

\pause

`for()`

```{r eval =F}
y = NULL
for (i in 1:ncol(X)) {
  y[i] = max(X[, i])
}
```




## Avoiding loops 

Group-wise calculations: `tapply()`

`tapply()` (`t` for table) may be used to do group-wise calculations
on vectors. Frequently it is employed to calculate group-wise
means.

```{r}
with(ToothGrowth, 
     tapply(len, list(supp, dose), mean))
```
(You could have done it with `aggregate()`)


## Writing functions 

Compute Cohen's *d*: 

```{r tidy = FALSE}
dcohen = function(group1, group2) { # Arguments
  mean_1 = mean(group1) ; mean_2 = mean(group2)
  var_1 = var(group1) ; var_2 = mean(group2) # body
  d = (mean_1 - mean_2)/sqrt(((var_1 + var_2)/2) )
  return(d) # results
}
```

Use it: 

```{r eval = FALSE}
dcohen(data$placebo, data$drug)
```

## Named arguments

Take this function: 

```{r eval = F, tidy=FALSE}
fun1 <- function(data, data.frame, graph, limit) { ... }

```

It can be called as: 


```{r eval =FALSE, tidy=FALSE}
fun1(d, df, TRUE, 20)
fun1(d, df, graph=TRUE, limit=20)
fun1(data=d, limit=20, graph=TRUE, data.frame=df)
```

Positional matching and keyword
matching (as in built-in functions)

## Defaults 

Arguments can be given default values $\rightarrow$ the arguments can be omitted!

```{r eval=FALSE}
fun1 <- function(data, data.frame, graph=TRUE,
                 limit=20) { ... }
```


It can be called as

```{r eval=F}
ans <- fun1(d, df)
```

which is now equivalent to the three cases above, but: 

```{r eval=F}
ans <- fun1(d, df, limit=10)
```

which changes one of the defaults.

## Methods and classes

The return value of a function may have a specified `class` $\rightarrow$ determines how it will be treated by other functions.

For example, many classes have tailored `print` methods.

```{r tidy=F, out.lines=7}
methods(print)
```

## Define a print method!

...as another function: 

```{r}
print.cohen <- function(obj){
  cat("\nMy Cohen's d\n\n")
  cat("Effect size: ", obj$d, "\n")
  invisible(obj) # return the object
}
```

We have to change our `dcohen` function a bit: 

```{r eval = FALSE}
dcohen = function(group1, group2) { # Arguments
  ...
  dvalue = list(d = d)
  class(dvalue) = "cohend"
  return(dvalue) # results
}
```

## Example 

```{r echo = FALSE}
dcohen = function(group1, group2) { # Arguments
  mean_1 = mean(group1) ; mean_2 = mean(group2)
  var_1 = var(group1) ; var_2 = mean(group2) # body
  d = (mean_1 - mean_2)/sqrt(((var_1 + var_2)/2) )
  dvalue = list(d = d)
  class(dvalue) = "cohend"
  return(dvalue) # results
}
print.cohen <- function(obj){
  cat("\nMy Cohen's d\n\n")
  cat("Effect size: ", obj$d, "\n")
  invisible(obj) # return the object
}
```


Compute the Cohen's *d* between a test group and a control group: 

```{r}
set.seed(082022) # results equal for everyone
data <- data.frame(drug = rnorm(6, 10), 
                   placebo = rnorm(6, 2))
my_d = dcohen(data$drug, data$placebo)
print.cohen(my_d)
```


## Debugging 

Use the `traceback()` function: 

```{r eval=FALSE}
foo <- function(x) { print(1); bar(2) }
bar <- function(x) { x + a.variable.which.does.not.exist }
```

Call `foo()` and... 

```{r eval = FALSE}
foo() # 
[1] 1
Error: object ’a.variable.which.does.not.exist’ not found
```


##

Use `traceback()`:

```{r eval=FALSE}
traceback() # find out where the error occurred
2: bar(2)
1: foo()
```

Note: `traceback()` appears as default

## String processing


```{r eval=FALSE}
substr(x, start, stop)        # extract substring
grep(pattern, x)              # match pattern
gsub(pattern, replacement, x) # replace pattern
```

`pattern` $=$ regular expression (`?regex`):

```{r eval= FALSE}
foo      # match pattern foo
.*       # match arbitrary character zero or more times
[a-z0-9] # match alphanumeric character
```

## Example

Match string that starts with `a` or `b` and replace it by its starting letter.


```{r}
gsub("(^[ab]).*", "\\1", c("aaa", "bbc", "cba"))
```
# Graphics

##

- Traditional graphics
- Grid graphics \& `ggplot2`

For both: 

- High level functions $\rightarrow$ actually produce the plot
- Low level functions $\rightarrow$ make it looks better =)

## Export graphics file


```{r eval = F}
postscript()  # vector graphics
pdf()

png()          # bitmap graphics
tiff()
jpeg()
bmp()
```


Remember to run off the graphic device once you've saved the graph:

```{r eval=FALSE}
dev.off()
```

(You can do it also manually)

## Traditional graphics I

High level functions

```{r eval = FALSE}
plot()      # scatter plot, specialized plot methods
boxplot()
hist()      # histogram
qqnorm()    # quantile-quantile plot
barplot()
pie()       # pie chart
pairs()     # scatter plot matrix
persp()     # 3d plot
contour()   # contour plot
coplot()    # conditional plot
interaction.plot()
```


`demo(graphics)` for a guided tour of base graphics!

## Traditional graphics II

Low level functions

```{r eval = FALSE}
points()       # add points
lines()        # add lines
rect()
polygon()
abline()       # add line with intercept a, slope b
arrows()
text()         # add text in plotting region
mtext()        # add text in margins region
axis()         # customize axes
box()          # box around plot
legend()
```

## Plot layout

Each plot is composed of two regions: 

- The plotting regions (contains the actual plot)
- The margins region (contain axes and labels)

A scatter plot: 

```{r eval = FALSE}
x <- runif(50, 0, 2) # 50 uniform random numbers
y <- runif(50, 0, 2)
plot(x, y, main="Title", 
     sub="Subtitle", xlab="x-label",
     ylab="y-label") # produce plotting window
```

Now add some text: 



```{r eval = FALSE}
text(0.6, 0.6, "Text at (0.6, 0.6)")
abline(h=.6, v=.6, lty=2) # horizont. and vertic. 
                          # lines
```

## Margins region 

\small

```{r eval=TRUE, echo=FALSE, out.width="100%"}
x <- runif(50, 0, 2) # 50 uniform random numbers
y <- runif(50, 0, 2)
plot(x, y, main="Title", 
     sub="Subtitle", xlab="x-label",
     ylab="y-label", cex.lab=1.5) # produce plotting window
text(0.6, 0.6, "Text at (0.6, 0.6)")
abline(h=.6, v=.6, lty=2) # horiz. and vert. lines

for(side in 1:4) mtext(-1:4, side=side, at=.7, line=-1:4)
mtext(paste("Side", 1:4), side=1:4, line=-1, font=2)
```
## Rome wasn't built in a day 
### and neither your graph

Display the interaction between the two factors of a two-factorial experiment: 

```{r eval=T}
dat <- read.table(header=TRUE, text="
A B rt
a1 b1 825
a1 b2 792
a1 b3 840
a2 b1 997
a2 b2 902
a2 b3 786
")
```

Force `A` and `B` to be `factor`:

```{r eval =TRUE}
dat[,1:2] = lapply(dat[,1:2], as.factor)
```

## First: The plot
\small
```{r eval = TRUE, out.width="80%"}
plot(rt ~ as.numeric(B), dat, type="n", axes=FALSE,
     xlim=c(.8, 3.2), ylim=c(750, 1000),
     xlab="Difficulty", ylab="Mean reaction time (ms)")
```

This will not result in anything! Well, it will just produce the container of the plot

## Populate the content

Plot the data points separately for each level of factor `A`.

```{r eval=FALSE}
points(rt ~ as.numeric(B), dat[dat$A=="a1",], 
       type="b", pch=16)
points(rt ~ as.numeric(B), dat[dat$A=="a2",], 
       type="b", pch=4)

```

Add axes and a legend.

```{r eval=FALSE}
axis(side=1, at=1:3, expression(B[1], B[2], B[3]))
axis(side=2) 
legend(2.5, 975, expression(A[1], A[2]), pch=c(16, 4),
       bty="n", title="Task")
```


## Final result

::: columns

:::: column
```{r echo=FALSE, out.width="100%"}
plot(rt ~ as.numeric(B), dat, type="n", axes=FALSE,
     xlim=c(.8, 3.2), ylim=c(750, 1000),
     xlab="Difficulty", ylab="Mean reaction time (ms)", 
     cex.lab=1.5)
points(rt ~ as.numeric(B), dat[dat$A=="a1",], 
       type="b", pch=16)
points(rt ~ as.numeric(B), dat[dat$A=="a2",], 
       type="b", pch=4)
axis(side=1, at=1:3, expression(B[1], B[2], B[3]))
axis(side=2) 
legend(2.5, 975, expression(A[1], A[2]), pch=c(16, 4),
       bty="n", title="Task")

```

::::

:::: column
- Error bars may be added
using the `arrows()`
function.

- Via `par()` many graphical
parameters may be set
(see `?par`), for example
`par(mgp=c(2, .7, 0))`
reduces the distance
between labels and axes
::::

:::


## Graphical parameters I

```{r eval=FALSE}
adj # justification of text
bty # box type for legend
cex # size of text or data symbols (multiplier)
col # color, see colors()
las # rotation of text in margins
lty # line type (solid, dashed, dotted, ...)
lwd # line width
mpg # placement of axis ticks and tick labels
pch # data symbol type
tck # length of axis ticks
type # type of plot (points, lines, both, none)
```

## Graphical parameters II


`par()`

```{r eval =FALSE}

mai # size of figure margins (inches)
mar # size of figure margins (lines of text)
mfrow # number of sub-figures on a page:
      # par(mfrow=c(1, 2)) creates two sub-figures
oma # size of outer margins (lines of text)
omi # size of outer margins (inches)
pty # aspect ratio of plot region (square, maximal)
```



## `ggplot2` 

\small

`ggplot2` (Grammar of Graphics plot, Wickman, 2016) is one of the best packages for plotting raw data and results: 

```{r eval=FALSE}
install.packages("ggplot2") ; library(ggplot2)
```

The code for the previous plot: 

```{r eval = FALSE}
ggplot(dat, aes(x = B, y = rt, group = A)) +  
  geom_point(pch=dat$A, size = 5) + 
  geom_line(aes(linetype=A), size=1)  + theme_classic() +
  ylab("RT") +  scale_linetype_manual("Task", values =c(3,4),
                                labels = c("A1", "A2")) +
  scale_x_discrete(labels = c("B1", "B2", "B3")) +
  theme(legend.position="top", 
        panel.background =  element_rect(fill = "#FAFAFA", 
                                         colour = "#FAFAFA"), 
        plot.background = element_rect(fill = "#FAFAFA"), 
        legend.key = element_rect(fill = "#FAFAFA"))
```

##

```{r eval = TRUE, out.with="100%", echo=FALSE}
ggplot(dat, aes(x = B, y = rt, group = A)) +  
  geom_point(pch=dat$A, size = 5) + 
  geom_line(aes(linetype=A), size=1)  + theme_classic() +
  ylab("RT") +  scale_linetype_manual("Task", values =c(3,4),
                                labels = c("A1", "A2")) +
  scale_x_discrete(labels = c("B1", "B2", "B3")) +
  theme(legend.position="top", 
        panel.background =  element_rect(fill = "#FAFAFA", 
                                         colour = "#FAFAFA"), 
        plot.background = element_rect(fill = "#FAFAFA"), 
        legend.key = element_rect(fill = "#FAFAFA"))
```


## Raw data

```{r out.width="50%"}
ggplot(rock, 
       aes(y=peri,x=shape, color =shape, 
           size = peri)) + geom_point() +
  theme_bw() + theme(legend.position = "none")
```


## Linear model 

```{r, message=FALSE, warning=FALSE, out.width="50%"}
ggplot(rock, 
       aes(y=peri,x=shape, color =shape, 
           size = peri)) + geom_point() +
  theme_bw() + theme(legend.position = "none") + 
  geom_smooth(method="lm")

```

## Multi Panel 

```{r echo = FALSE, out.width="80%"}
states = data.frame(state.x77, state.name = state.name,
state.region = state.region)

ggplot(states, 
       aes(x = Population, y = Murder, 
           size = Illiteracy)) + geom_point() +
  facet_wrap(~state.region) + theme_bw() 
```
## Multi panel code 

```{r eval=FALSE}
states = data.frame(state.x77, state.name = state.name,
                    state.region = state.region)

ggplot(states, 
       aes(x = Population, y = Murder, 
           size = Illiteracy)) + geom_point() +
  facet_wrap(~state.region) + theme_bw() 
```


## Different plots in the same panel

\small 

use `grid.arrange()` function from the `gridExtra` package: 

```{r eval = FALSE}
install.packages("grideExtra") 
library(gridExtra)
```


```{r eval = FALSE}
murder_raw = ggplot(states,  # raw data
               aes(x = Illiteracy, y = Murder)) +
           .....

murder_lm = ggplot(states,  # lm 
               aes(x = Illiteracy, y = Murder)) +
           .....
            
```

Combine the plots together: 

```{r eval = FALSE}
grid.arrange(murder_raw, murder_lm, 
             nrow=1) # plots forced to be the same row
```

 

## Combine the plots together 
\small

```{r echo = FALSE}

murder_raw = ggplot(states,  # raw data
               aes(x = Illiteracy, y = Murder)) + geom_point(size =3, pch=3) + theme_classic() + theme(legend.position = "none")

murder_lm = ggplot(states,  # raw data
               aes(x = Illiteracy, y = Murder)) + geom_point(size =3, pch=3) + theme_classic() + 
  geom_smooth(method="lm", color="red", aes(fill="red")) + theme(legend.position = "none")
```


```{r echo = FALSE}
grid.arrange(murder_raw, murder_lm, 
             nrow=1)
```




<!-- ## Execersizes -->

<!-- - Open a new `R` script -->

<!-- - Create one vector for each type (`int`, `num`, `chr`, `logi`, `factor`) and assign each of them to an object -->

<!-- - Compute the mean of the  `int` and `num` vectors -->

<!-- - Standardize the values of the `int` and `num` vectors and store them in two new objects:  -->

<!-- $$ z = \frac{x_i - \bar{X}}{sd}$$ -->

<!-- - Create a new vector by combining together the `logi` and `int` vectors -->

<!-- - Add the `logi` vector to the `num` vector -->

